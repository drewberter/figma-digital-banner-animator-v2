/**
 * Link Registry - Centralized storage for layer linking information
 * 
 * This enhanced version provides more complete implementations
 * of linking operations for better layer management
 */

import { LinkRegistry as LinkRegistryClass } from './linkRegistryInterfaces';
import { GifFrame, Animation, LinkSyncMode, AnimationLayer, LinkedLayerInfo } from '../types/animation';
import { findLayerById } from './directLayerLinking-fixed';
import { parseGifFrameId } from './linkingUtils';

// Create a class that extends the base registry with additional methods
class LinkRegistryExtended extends LinkRegistryClass {
  // Internal storage for frame references (for GIF mode)
  private frameCache: GifFrame[] = [];
  
  // Internal flag for GIF frame mode
  private isGifFrameMode: boolean = false;
  
  /**
   * Original linkLayers method from the interface
   * Creates a group and links layers by name (compatible with existing code)
   */
  public linkLayers(
    layerName: string, 
    layerIds: string[], 
    mode: 'animation' | 'gif' = 'animation', 
    mainLayerId?: string
  ): string {
    console.log(`Linking layers with name: ${layerName}, ids: ${layerIds.join(', ')}, mode: ${mode}`);
    
    // Create the group in the registry directly using our consistent ID generation
    const mainId = mainLayerId || layerIds[0];
    const group = this.createGroup(layerName, mainId, mode);
    
    // Use the ID generated by createGroup for consistency
    const groupId = group.id;
    
    console.log(`Using consistent link-group ID format: ${groupId} for ${mode} mode`);
    
    // Add all layers to the group
    layerIds.forEach((layerId, index) => {
      // Get the registered groupId from createGroup as it might be different  
      // than our locally generated one
      const registeredGroupId = this.getLayerGroup(mainId)?.id;
      
      if (registeredGroupId) {
        // Use the registered group ID from the registry
        this.addLayerToGroup(registeredGroupId, layerId);
        console.log(`Layer ${layerId} added to group ${registeredGroupId}`);
      } else {
        console.error(`Failed to find registered group for main layer ${mainId}`);
      }
    });
    
    return groupId;
  }
  
  /**
   * Extended version of linkLayers for direct frame manipulation
   * This is used by the enhanced functionality in the app
   */
  public linkLayersInFrames(
    frames: GifFrame[] | Record<string, AnimationLayer[]>, 
    mainLayerId: string, 
    adSizeId?: string
  ): GifFrame[] | Record<string, AnimationLayer[]> {
    console.log(`Linking layers in frames with main layer: ${mainLayerId}`);
    
    // Handle different data structure types
    if (Array.isArray(frames)) {
      // Handle GIF frames array
      return this.linkLayersInGifFrames(frames, mainLayerId);
    } else {
      // Handle frames record (animation mode)
      return this.linkLayersInFramesRecord(frames, mainLayerId, adSizeId);
    }
  }
  
  /**
   * Implementation for linking layers in GIF frames array
   */
  private linkLayersInGifFrames(frames: GifFrame[], mainLayerId: string): GifFrame[] {
    // Create a copy to avoid mutation
    const updatedFrames = JSON.parse(JSON.stringify(frames));
    
    // First, find the source layer and its name
    let sourceLayer: AnimationLayer | null = null;
    let sourceFrameId: string = '';
    
    // Find the frame containing the main layer
    for (const frame of updatedFrames) {
      if (!frame.layers) continue;
      
      const layer = findLayerById(frame.layers, mainLayerId);
      if (layer) {
        sourceLayer = layer;
        sourceFrameId = frame.id;
        break;
      }
    }
    
    if (!sourceLayer || !sourceLayer.name) {
      console.error(`Main layer ${mainLayerId} not found or has no name`);
      return frames;
    }
    
    // Create the Link Group in our registry first to get a proper ID
    this.createGroup(sourceLayer.name, mainLayerId, 'gif');
    
    // Now get the actual group ID from the registry
    const registeredGroup = this.getLayerGroup(mainLayerId);
    
    if (!registeredGroup) {
      console.error(`Failed to register link group for layer ${mainLayerId}`);
      return frames; // Abort if we couldn't create the group
    }
    
    const groupId = registeredGroup.id;
    console.log(`Using registry group ID: ${groupId} for layers named "${sourceLayer.name}"`);
    
    // Set up the source layer as the main linked layer
    sourceLayer.linkedLayer = {
      id: sourceLayer.id,
      layerId: sourceLayer.id,
      frameId: sourceFrameId,
      name: sourceLayer.name || '',
      hasOverride: false,
      groupId,
      isMain: true,
      syncMode: LinkSyncMode.Full, // Updated to correct enum value
      overrides: []
    };
    sourceLayer.isLinked = true;
    
    // Register this layer with the registry
    this.addLayerToGroup(groupId, mainLayerId, sourceFrameId);
    
    // Now find all layers with the same name in other frames
    const sourceName = sourceLayer.name.toLowerCase();
    
    // Go through all other frames to find matching layers
    for (const frame of updatedFrames) {
      if (!frame.layers || frame.id === sourceFrameId) continue;
      
      // Helper to find and link layers by name 
      const findAndLinkLayers = (layers: AnimationLayer[]): void => {
        for (const layer of layers) {
          if (layer.name && layer.name.toLowerCase() === sourceName) {
            // Set up this layer as a linked layer
            layer.linkedLayer = {
              id: layer.id,
              layerId: layer.id,
              frameId: frame.id,
              name: layer.name || '',
              hasOverride: false,
              groupId,
              isMain: false,
              syncMode: LinkSyncMode.Full, // Updated to correct enum value
              overrides: []
            };
            layer.isLinked = true;
            
            // Register with the registry
            this.addLayerToGroup(groupId, layer.id, frame.id);
            console.log(`Linked layer "${layer.name}" in frame ${frame.id}`);
          }
          
          // Check children
          if (layer.children && layer.children.length > 0) {
            findAndLinkLayers(layer.children);
          }
        }
      };
      
      findAndLinkLayers(frame.layers);
    }
    
    return updatedFrames;
  }
  
  /**
   * Implementation for linking layers in animation mode frames record
   */
  private linkLayersInFramesRecord(
    framesRecord: Record<string, AnimationLayer[]>,
    mainLayerId: string,
    adSizeId?: string
  ): Record<string, AnimationLayer[]> {
    // Create a copy to avoid mutation
    const updatedFramesRecord = JSON.parse(JSON.stringify(framesRecord));
    
    // First, find the source layer and its name
    let sourceLayer: AnimationLayer | null = null;
    let sourceFrameId: string = '';
    
    // Find the frame containing the main layer
    for (const frameId in updatedFramesRecord) {
      const layers = updatedFramesRecord[frameId];
      if (!layers || !Array.isArray(layers)) continue;
      
      sourceLayer = findLayerById(layers, mainLayerId);
      if (sourceLayer) {
        sourceFrameId = frameId;
        break;
      }
    }
    
    if (!sourceLayer || !sourceLayer.name) {
      console.error(`Main layer ${mainLayerId} not found or has no name`);
      return framesRecord;
    }
    
    // Create the Link Group in our registry first to get a proper ID
    this.createGroup(sourceLayer.name, mainLayerId, 'animation');
    
    // Now get the actual group ID from the registry
    const registeredGroup = this.getLayerGroup(mainLayerId);
    
    if (!registeredGroup) {
      console.error(`Failed to register link group for layer ${mainLayerId}`);
      return framesRecord; // Abort if we couldn't create the group
    }
    
    const groupId = registeredGroup.id;
    console.log(`Using registry group ID: ${groupId} for layers named "${sourceLayer.name}"`);
    
    // Set up the source layer as the main linked layer
    sourceLayer.linkedLayer = {
      id: sourceLayer.id,
      layerId: sourceLayer.id,
      frameId: sourceFrameId,
      name: sourceLayer.name || '',
      hasOverride: false,
      groupId,
      isMain: true,
      syncMode: LinkSyncMode.Full, // Updated to correct enum value
      overrides: []
    };
    sourceLayer.isLinked = true;
    
    // Register this layer with the registry
    this.addLayerToGroup(groupId, mainLayerId, sourceFrameId);
    
    // Now find all layers with the same name in other frames
    const sourceName = sourceLayer.name.toLowerCase();
    
    // Go through all other frames to find matching layers
    for (const frameId in updatedFramesRecord) {
      if (frameId === sourceFrameId) continue;
      
      const layers = updatedFramesRecord[frameId];
      if (!layers || !Array.isArray(layers)) continue;
      
      // Helper to find and link layers by name 
      const findAndLinkLayers = (frameLayers: AnimationLayer[]): void => {
        for (const layer of frameLayers) {
          if (layer.name && layer.name.toLowerCase() === sourceName) {
            // Set up this layer as a linked layer
            layer.linkedLayer = {
              id: layer.id,
              layerId: layer.id,
              frameId: frameId,
              name: layer.name || '',
              hasOverride: false,
              groupId,
              isMain: false,
              syncMode: LinkSyncMode.Full, // Updated to correct enum value
              overrides: []
            };
            layer.isLinked = true;
            
            // Register with the registry
            this.addLayerToGroup(groupId, layer.id, frameId);
            console.log(`Linked layer "${layer.name}" in frame ${frameId}`);
          }
          
          // Check children
          if (layer.children && layer.children.length > 0) {
            findAndLinkLayers(layer.children);
          }
        }
      };
      
      findAndLinkLayers(layers);
    }
    
    return updatedFramesRecord;
  }
  
  /**
   * Method to unlink a layer with additional effects
   * This full implementation handles both GIF frames and animation mode
   */
  public unlinkLayer(
    frames: GifFrame[] | Record<string, AnimationLayer[]>, 
    layerId: string, 
    adSizeId?: string
  ): GifFrame[] | Record<string, AnimationLayer[]> {
    console.log(`Unlinking layer: ${layerId}`);
    
    // First get the layer's group
    const group = this.getLayerGroup(layerId);
    if (!group) {
      console.warn(`Layer ${layerId} is not linked to any group`);
      return frames;
    }
    
    // Call base method to remove from registry
    super.removeLayer(layerId);
    
    // Handle different data structure types
    if (Array.isArray(frames)) {
      // GIF frames array
      return this.unlinkLayerInGifFrames(frames, layerId, group.id);
    } else {
      // Frames record
      return this.unlinkLayerInFramesRecord(frames, layerId, group.id);
    }
  }
  
  /**
   * Implementation for unlinking a layer in GIF frames array
   */
  private unlinkLayerInGifFrames(
    frames: GifFrame[], 
    layerId: string, 
    groupId: string
  ): GifFrame[] {
    // Create a copy to avoid mutation
    const updatedFrames = JSON.parse(JSON.stringify(frames));
    
    // Find the layer to unlink
    for (const frame of updatedFrames) {
      if (!frame.layers) continue;
      
      // Helper to find and unlink the layer
      const findAndUnlinkLayer = (layers: AnimationLayer[]): boolean => {
        for (let i = 0; i < layers.length; i++) {
          if (layers[i].id === layerId) {
            // Remove linked properties
            delete layers[i].linkedLayer;
            layers[i].isLinked = false;
            console.log(`Unlinked layer ${layerId} from group ${groupId}`);
            return true;
          }
          
          // Check children
          const children = layers[i].children;
          if (children && Array.isArray(children) && children.length > 0) {
            if (findAndUnlinkLayer(children)) {
              return true;
            }
          }
        }
        
        return false;
      };
      
      if (frame.layers && Array.isArray(frame.layers)) {
        findAndUnlinkLayer(frame.layers);
      }
    }
    
    return updatedFrames;
  }
  
  /**
   * Implementation for unlinking a layer in animation mode frames record
   */
  private unlinkLayerInFramesRecord(
    framesRecord: Record<string, AnimationLayer[]>,
    layerId: string,
    groupId: string
  ): Record<string, AnimationLayer[]> {
    // Create a copy to avoid mutation
    const updatedFramesRecord = JSON.parse(JSON.stringify(framesRecord));
    
    // Find the layer to unlink in all frames
    for (const frameId in updatedFramesRecord) {
      const layers = updatedFramesRecord[frameId];
      if (!layers || !Array.isArray(layers)) continue;
      
      // Helper to find and unlink the layer
      const findAndUnlinkLayer = (frameLayers: AnimationLayer[]): boolean => {
        for (let i = 0; i < frameLayers.length; i++) {
          if (frameLayers[i].id === layerId) {
            // Remove linked properties
            delete frameLayers[i].linkedLayer;
            frameLayers[i].isLinked = false;
            console.log(`Unlinked layer ${layerId} from group ${groupId}`);
            return true;
          }
          
          // Check children
          const children = frameLayers[i].children;
          if (children && Array.isArray(children) && children.length > 0) {
            if (findAndUnlinkLayer(children)) {
              return true;
            }
          }
        }
        
        return false;
      };
      
      findAndUnlinkLayer(layers);
    }
    
    return updatedFramesRecord;
  }
  
  /**
   * Method to handle GIF frame mode changes
   * Enables special functions for working with GIF frames
   */
  public gifFrameMode(enabled: boolean): { framesByNumber: (frameNumber: string) => GifFrame[] } {
    console.log(`GIF frame mode ${enabled ? 'enabled' : 'disabled'}`);
    this.isGifFrameMode = enabled;
    
    // Return an object with framesByNumber method to find frames by number
    const self = this;
    return {
      framesByNumber: function(frameNumber: string): GifFrame[] {
        return self.findFramesByNumber(self.frameCache, frameNumber);
      }
    };
  }
  
  /**
   * Method to find frames by number
   * Returns all frames with the given frame number
   */
  public findFramesByNumber(frames: GifFrame[] | string, frameNumber?: string | number): GifFrame[] {
    // Handle string first argument
    if (typeof frames === 'string') {
      frameNumber = frames;
      frames = this.frameCache;
    }
    
    // Handle non-array frames
    if (!Array.isArray(frames)) {
      return [];
    }
    
    // Cache the frames for later use
    this.frameCache = frames;
    
    // Convert frameNumber to string for safe comparison
    const frameNumberStr = frameNumber !== undefined ? String(frameNumber) : '';
    
    console.log(`[findFramesByNumber] Looking for frames with number: ${frameNumberStr}`);
    
    // Filter frames by number
    const matchingFrames = frames.filter(frame => {
      // Parse the frame ID
      const parsedId = parseGifFrameId(frame.id);
      
      // For debugging
      if (parsedId.isValid) {
        console.log(`[findFramesByNumber] Frame ${frame.id} has number: ${parsedId.frameNumber} (${typeof parsedId.frameNumber}), comparing to ${frameNumberStr} (${typeof frameNumberStr})`);
      }
      
      // Return frames matching the number (string comparison)
      return parsedId.isValid && String(parsedId.frameNumber) === frameNumberStr;
    });
    
    console.log(`[findFramesByNumber] Found ${matchingFrames.length} frames with number ${frameNumberStr}`);
    return matchingFrames;
  }
}

// Create a singleton instance
export const linkRegistry = new LinkRegistryExtended();